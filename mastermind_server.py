import socket
import random
import itertools
import threading

# --- Server Configuration ---
HOST = '0.0.0.0'  # Listen on all available interfaces
PORT = 8888       # Port for the Telnet server

# --- Telnet Protocol Special Bytes ---
# These are used to parse Telnet negotiation sequences
IAC = 255 # Interpret As Command
DO = 251
DONT = 252
WILL = 253
WONT = 254
SB = 250  # Subnegotiation Begin
SE = 240  # Subnegotiation End

# --- Utility Functions for Socket Communication ---
def send_message(sock, message):
    """Sends a message to the client, ensuring it's terminated with CR+LF for Telnet."""
    try:
        sock.sendall((message + "\r\n").encode('utf-8'))
    except BrokenPipeError:
        # Connection closed by client, propagate as a specific error
        raise ConnectionResetError("Client disconnected while sending message")

def recv_line_telnet(sock):
    """
    Reads a line from a Telnet socket, handling IAC (Interpret As Command) sequences.
    This function will discard Telnet negotiation bytes and only return actual user input.
    """
    buffer = b''
    in_iac_sequence = False
    in_subnegotiation = False
    
    while True:
        byte_data = sock.recv(1) # Read byte by byte
        if not byte_data:
            # Client disconnected
            raise ConnectionResetError("Client disconnected during input")
        
        byte_val = byte_data[0] # Get the integer value of the byte

        if in_iac_sequence:
            # We are currently inside an IAC sequence, process the command byte
            if in_subnegotiation:
                # If we're in a subnegotiation block
                if byte_val == IAC: # Double IAC means actual byte 255
                    buffer += byte_data # Add the actual byte 255 to buffer
                    in_iac_sequence = False # Exit IAC sequence
                elif byte_val == SE: # End of subnegotiation
                    in_iac_sequence = False
                    in_subnegotiation = False
                # else: discard bytes within subnegotiation until SE or IAC IAC
            else: # Not in subnegotiation, expect a command after IAC
                if byte_val in (DO, DONT, WILL, WONT):
                    # These commands are followed by an option byte, so read and discard it
                    sock.recv(1) 
                    in_iac_sequence = False # Exit IAC sequence
                elif byte_val == SB: # Subnegotiation begins
                    in_subnegotiation = True
                elif byte_val == IAC: # Escaped IAC (actual byte 255)
                    buffer += byte_data # Add the actual byte 255 to buffer
                    in_iac_sequence = False # Exit IAC sequence
                else:
                    # Other simple IAC commands (like NOP, DATA MARK, etc.) are 1 byte after IAC
                    in_iac_sequence = False # Exit IAC sequence
        elif byte_val == IAC: # Start of an IAC sequence (0xFF)
            in_iac_sequence = True
        else:
            # This is a regular data byte
            buffer += byte_data
            if buffer.endswith(b'\r\n'): # Check for Telnet line ending
                return buffer.decode('utf-8').strip() # Decode and remove whitespace


def get_input(sock, prompt):
    """Prompts the client for input and returns the cleaned string."""
    try:
        send_message(sock, prompt)
        return recv_line_telnet(sock)
    except ConnectionResetError:
        raise # Propagate the error if the client disconnects

# --- Game Functions (Adapted for Socket I/O) ---
# (These remain largely the same, but use send_message and get_input)

def generate_secret_code():
    """Generates a 4-digit unique secret code."""
    digits = [str(i) for i in range(10)]
    random.shuffle(digits)
    code = "".join(digits[:4]) 
    return code

def calculate_feedback(secret_code, guess):
    """Calculates 'bulls' and 'cows'."""
    bulls = 0
    cows = 0
    for i in range(4):
        if guess[i] == secret_code[i]:
            bulls += 1
    
    secret_set = set(secret_code)
    guess_set = set(guess)
    common_digits = len(secret_set.intersection(guess_set))
    cows = common_digits - bulls
            
    return bulls, cows

def is_valid_code(code):
    """Checks if a string is a valid 4-digit unique code."""
    return len(code) == 4 and code.isdigit() and len(set(code)) == 4

# --- Round 1: Player is the Guesser, Computer is the Code Maker ---

def player_guesses_round(client_sock):
    """Player tries to guess the code generated by the computer."""
    send_message(client_sock, "\n--- Round 1: Computer is the Code Maker ---")
    computer_secret_code = generate_secret_code()
    num_attempts = 0
    max_attempts = 10 

    send_message(client_sock, f"I have generated a 4-digit unique secret code. You have {max_attempts} attempts.")

    while num_attempts < max_attempts:
        num_attempts += 1
        send_message(client_sock, f"\nAttempt {num_attempts}/{max_attempts}:")
        
        player_guess = get_input(client_sock, "Enter your guess (4 unique digits): ")

        if not is_valid_code(player_guess):
            send_message(client_sock, "Invalid input. Please enter exactly 4 unique digits.")
            num_attempts -= 1 
            continue

        bulls, cows = calculate_feedback(computer_secret_code, player_guess)
        send_message(client_sock, f"Feedback: {bulls} bulls, {cows} cows.")

        if bulls == 4:
            send_message(client_sock, f"\n🥳 Congratulations! You guessed the code '{computer_secret_code}' in {num_attempts} attempts!")
            return True 
    
    send_message(client_sock, f"\n🥲 You ran out of {max_attempts} attempts. The secret code was '{computer_secret_code}'.")
    return False

# --- Round 2: Computer is the Guesser, Player is the Code Maker ---

def generate_all_possible_codes():
    """Generates a list of all possible 4-digit unique codes."""
    digits = [str(i) for i in range(10)]
    possible_codes = ["".join(p) for p in itertools.permutations(digits, 4)]
    return possible_codes

def computer_guesses_round(client_sock):
    """The computer tries to guess the code set by the player."""
    send_message(client_sock, "\n--- Round 2: You are the Code Maker ---")
    send_message(client_sock, "Think of a 4-digit unique secret code (e.g., 1234, 0987).")
    send_message(client_sock, "Don't tell anyone! I (the computer) will try to guess it.")
    send_message(client_sock, "After each of my guesses, please provide the feedback (bulls and cows).")
    
    remaining_codes = generate_all_possible_codes()
    num_attempts_comp = 0
    
    while True:
        num_attempts_comp += 1
        
        if not remaining_codes:
            send_message(client_sock, "\n🤔 Oops! It seems I ran out of options or you provided incorrect feedback.")
            send_message(client_sock, "I cannot guess your code. Game over.")
            return False

        computer_guess = random.choice(remaining_codes)

        send_message(client_sock, f"\nComputer's Attempt {num_attempts_comp}: I guess '{computer_guess}'.")
        
        while True:
            try:
                bulls_str = get_input(client_sock, "How many 'bulls' do I have (correct digit in correct position)? ")
                cows_str = get_input(client_sock, "How many 'cows' do I have (correct digit in wrong position)? ")
                
                player_bulls = int(bulls_str)
                player_cows = int(cows_str)

                if not (0 <= player_bulls <= 4 and
                        0 <= player_cows <= 4 and
                        player_bulls + player_cows <= 4):
                    send_message(client_sock, "Invalid feedback. Bulls and cows must be numbers between 0 and 4, and their sum must not exceed 4.")
                    continue
                break
            except ValueError:
                send_message(client_sock, "Invalid input. Please enter a number.")
        
        if player_bulls == 4:
            send_message(client_sock, f"\n🎉 I guessed it! Your code was '{computer_guess}'! It took me {num_attempts_comp} attempts.")
            return True

        new_remaining_codes = []
        for possible_code in remaining_codes:
            test_bulls, test_cows = calculate_feedback(possible_code, computer_guess)
            
            if (test_bulls == player_bulls and
                test_cows == player_cows):
                new_remaining_codes.append(possible_code)
        
        remaining_codes = new_remaining_codes
        send_message(client_sock, f"I've narrowed down the possible codes to {len(remaining_codes)}.")

# --- Main Game Function (Adapted for Socket I/O) ---

def play_mastermind(client_sock):
    """The main function that orchestrates both rounds of the Mastermind game."""
    send_message(client_sock, "🎉 Welcome to Mastermind! 🎉")
    send_message(client_sock, "The goal is to guess the 4-digit unique secret code.")
    
    # Round 1
    player_won_round1 = player_guesses_round(client_sock)

    # Round 2
    computer_won_round2 = computer_guesses_round(client_sock)

    send_message(client_sock, "\n--- Game Summary ---")
    if player_won_round1:
        send_message(client_sock, "✅ In Round 1 (you guess), you won!")
    else:
        send_message(client_sock, "❌ In Round 1 (you guess), you lost.")
    
    if computer_won_round2:
        send_message(client_sock, "✅ In Round 2 (computer guesses), the computer guessed your code!")
    else:
        send_message(client_sock, "❌ In Round 2 (computer guesses), the computer couldn't guess your code (likely due to incorrect feedback or lack of options).")

    send_message(client_sock, "\nThanks for playing! See you soon! 👋")
    send_message(client_sock, "--- End of Game ---")


# --- Client Connection Handler ---
def handle_client_connection(client_sock, addr):
    """Handles a single connected client."""
    print(f"[*] Accepted connection from {addr[0]}:{addr[1]}")
    try:
        play_mastermind(client_sock)
    except ConnectionResetError as e:
        print(f"[-] Client {addr[0]}:{addr[1]} disconnected: {e}")
    except Exception as e:
        # Catch any other unexpected errors during game play
        print(f"[!] Error handling client {addr[0]}:{addr[1]}: {e}")
        try:
            send_message(client_sock, "An unexpected error occurred. Disconnecting.")
        except:
            pass # Ignore errors on sending final message
    finally:
        client_sock.close()
        print(f"[*] Connection with {addr[0]}:{addr[1]} closed.")

# --- Main Server Function ---
def start_mastermind_server():
    """Starts the Mastermind server and listens for connections."""
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 
    server.bind((HOST, PORT))
    server.listen(5) 

    print(f"[*] Mastermind server listening on {HOST}:{PORT}")
    print("Press Ctrl+C to stop the server.")

    while True:
        try:
            client_sock, addr = server.accept()
            client_handler = threading.Thread(
                target=handle_client_connection,
                args=(client_sock, addr)
            )
            client_handler.start()
        except KeyboardInterrupt:
            print("\n[*] Shutting down server...")
            break
        except Exception as e:
            print(f"[!] Server error: {e}")
            break
    
    server.close()

# --- Start Server ---
if __name__ == "__main__":
    start_mastermind_server()